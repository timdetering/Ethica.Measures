// <autogenerated>
// This code was generated by a tool. Any changes made manually will be lost
// the next time this code is regenerated.
// </autogenerated>

namespace Ethica.Measurements.Volumes
{
    using System;
    
    /// <summary>
    /// Value which represents a Volume in any popular unit of measure
    /// </summary>
    public partial struct Volume :
        IVolume,
        IFormattable,
        IEquatable<Volume>,
        IComparable<Volume>, 
    	IComparable,
        IEquatable<Liters>,
        IEquatable<CubicMeters>,
        IEquatable<CubicCentimeters>,
        IEquatable<CubicFeet>,
        IEquatable<CubicInches>,
        IEquatable<CubicYards>,
        IEquatable<FluidOuncesUK>,
        IEquatable<FluidOunces>,
        IEquatable<PintsUK>,
        IEquatable<Pints>,
        IEquatable<QuartsUK>,
        IEquatable<Quarts>,
        IEquatable<GallonsUK>,
        IEquatable<Gallons>,
        IComparable<Liters>,
        IComparable<CubicMeters>,
        IComparable<CubicCentimeters>,
        IComparable<CubicFeet>,
        IComparable<CubicInches>,
        IComparable<CubicYards>,
        IComparable<FluidOuncesUK>,
        IComparable<FluidOunces>,
        IComparable<PintsUK>,
        IComparable<Pints>,
        IComparable<QuartsUK>,
        IComparable<Quarts>,
        IComparable<GallonsUK>,
        IComparable<Gallons>
    {
    	#region Fields
    
        /// <summary>
        /// The value of the Volume represented by UnitOfMeasure
        /// </summary>
        readonly decimal _value;
    
        /// <summary>
        /// The VolumeUnit to which Value applies
        /// </summary>
        readonly VolumeUnit _unitOfMeasure;
    
    	#endregion
    
    	#region Properties
    
        /// <summary>
        /// The value of the Volume represented by UnitOfMeasure
        /// </summary>
        public decimal Value { get { return _value; } }
    
        /// <summary>
        /// The VolumeUnit to which Value applies
        /// </summary>
        public VolumeUnit UnitOfMeasure { get { return _unitOfMeasure; } }
    	
    	#endregion
    
        /// <summary>
        /// Constructs a new Volume
        /// </summary>
        /// <param name="value">The value of the Volume</param>
        /// <param name="unitOfMeasure">Optional. The unit of measure which value represents. Defaults to Literss</param>
        public Volume(decimal value, VolumeUnit unitOfMeasure)
        {
            _value = value;
            _unitOfMeasure = unitOfMeasure;
        }
    
    	/// <summary>
        /// Constructs a new Volume
        /// </summary>
        /// <param name="value">The value of the Volume</param>
        /// <param name="unitOfMeasure">Optional. The unit of measure which value represents. Defaults to Literss</param>
        public Volume(decimal value)
        {
            _value = value;
            _unitOfMeasure = VolumeUnit.Liters;
        }
    
        /// <summary>
        /// Converts the Volume from one unit of measure to another
        /// </summary>
        /// <param name="unitOfMeasure"></param>
        /// <returns></returns>
        public Volume ConvertTo(VolumeUnit unitOfMeasure)
        {
            if (this._unitOfMeasure == unitOfMeasure)
                return this;
    
            decimal val = this.Value;
    
            // Convert current value back to meters
            if (this._unitOfMeasure != VolumeUnit.Liters)
                val /= UnitsPerLiters[(int)this._unitOfMeasure];
    
            // Convert meters to target measure
            if (unitOfMeasure != VolumeUnit.Liters)
                val *= UnitsPerLiters[(int)unitOfMeasure];
    
            return new Volume(val, unitOfMeasure);
        }
    
        #region Equality
    
        /// <summary>
        /// Equates whether this value is the same value as another value. 
        /// </summary>
        /// <param name="other">The other Volume to equate</param>
        /// <returns>true if the values represent the same Volume</returns>
        public bool Equals(Volume other)
        {
            return this.Value == other.ConvertTo(this._unitOfMeasure).Value;
        }
    
        /// <summary>
        /// Equates whether this value is the same as another value.
        /// </summary>
        /// <param name="obj">The IVolume to compare to</param>
        /// <returns>True if both values are equal</returns>
        public override bool Equals(object obj)
        {
            var other = obj as IVolume;
            if (other != null)
                return Equals(other.Volume);
    
            return false;
        }
    
        public static bool operator ==(Volume argA, Volume argB)
        {
            return argA.Equals(argB);
        }
    
        public static bool operator !=(Volume argA, Volume argB)
        {
            return !argA.Equals(argB);
        }
    
    	public bool Equals(Liters other) { return ConvertTo(VolumeUnit.Liters).Value == other.Value; }
    	public bool Equals(CubicMeters other) { return ConvertTo(VolumeUnit.CubicMeters).Value == other.Value; }
    	public bool Equals(CubicCentimeters other) { return ConvertTo(VolumeUnit.CubicCentimeters).Value == other.Value; }
    	public bool Equals(CubicFeet other) { return ConvertTo(VolumeUnit.CubicFeet).Value == other.Value; }
    	public bool Equals(CubicInches other) { return ConvertTo(VolumeUnit.CubicInches).Value == other.Value; }
    	public bool Equals(CubicYards other) { return ConvertTo(VolumeUnit.CubicYards).Value == other.Value; }
    	public bool Equals(FluidOuncesUK other) { return ConvertTo(VolumeUnit.FluidOuncesUK).Value == other.Value; }
    	public bool Equals(FluidOunces other) { return ConvertTo(VolumeUnit.FluidOunces).Value == other.Value; }
    	public bool Equals(PintsUK other) { return ConvertTo(VolumeUnit.PintsUK).Value == other.Value; }
    	public bool Equals(Pints other) { return ConvertTo(VolumeUnit.Pints).Value == other.Value; }
    	public bool Equals(QuartsUK other) { return ConvertTo(VolumeUnit.QuartsUK).Value == other.Value; }
    	public bool Equals(Quarts other) { return ConvertTo(VolumeUnit.Quarts).Value == other.Value; }
    	public bool Equals(GallonsUK other) { return ConvertTo(VolumeUnit.GallonsUK).Value == other.Value; }
    	public bool Equals(Gallons other) { return ConvertTo(VolumeUnit.Gallons).Value == other.Value; }
    	#endregion
    
        #region Comparison
    
        public static bool operator <(Volume arg1, Volume arg2)
        {
            return arg1.CompareTo(arg2) == -1;
        }
    
        public static bool operator >(Volume arg1, Volume arg2)
        {
            return arg1.CompareTo(arg2) == 1;
        }
    
        /// <summary>
        /// Compares to another object
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public int CompareTo(object obj)
        {
            var other = obj as IVolume;
            if (other != null)
                return CompareTo(other.Volume);
    
            throw new ArgumentException("Invalid Argument","obj");
        }
    
        /// <summary>
        /// Comapres to another Volume
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(Volume other)
        {
            return this.Value.CompareTo(other.ConvertTo(this._unitOfMeasure).Value);
        }
    
    	public int CompareTo(Liters other) { return ConvertTo(VolumeUnit.Liters).Value.CompareTo(other.Value); }
    	public int CompareTo(CubicMeters other) { return ConvertTo(VolumeUnit.CubicMeters).Value.CompareTo(other.Value); }
    	public int CompareTo(CubicCentimeters other) { return ConvertTo(VolumeUnit.CubicCentimeters).Value.CompareTo(other.Value); }
    	public int CompareTo(CubicFeet other) { return ConvertTo(VolumeUnit.CubicFeet).Value.CompareTo(other.Value); }
    	public int CompareTo(CubicInches other) { return ConvertTo(VolumeUnit.CubicInches).Value.CompareTo(other.Value); }
    	public int CompareTo(CubicYards other) { return ConvertTo(VolumeUnit.CubicYards).Value.CompareTo(other.Value); }
    	public int CompareTo(FluidOuncesUK other) { return ConvertTo(VolumeUnit.FluidOuncesUK).Value.CompareTo(other.Value); }
    	public int CompareTo(FluidOunces other) { return ConvertTo(VolumeUnit.FluidOunces).Value.CompareTo(other.Value); }
    	public int CompareTo(PintsUK other) { return ConvertTo(VolumeUnit.PintsUK).Value.CompareTo(other.Value); }
    	public int CompareTo(Pints other) { return ConvertTo(VolumeUnit.Pints).Value.CompareTo(other.Value); }
    	public int CompareTo(QuartsUK other) { return ConvertTo(VolumeUnit.QuartsUK).Value.CompareTo(other.Value); }
    	public int CompareTo(Quarts other) { return ConvertTo(VolumeUnit.Quarts).Value.CompareTo(other.Value); }
    	public int CompareTo(GallonsUK other) { return ConvertTo(VolumeUnit.GallonsUK).Value.CompareTo(other.Value); }
    	public int CompareTo(Gallons other) { return ConvertTo(VolumeUnit.Gallons).Value.CompareTo(other.Value); }
    
        public override int GetHashCode()
        {
            return this.Value.GetHashCode();
        }
    
            #endregion
    
    		#region Arithmetic operator overload
    
    	public static Volume operator +(Volume argA, Liters argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, Liters argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(Liters other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(Liters other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, CubicMeters argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, CubicMeters argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(CubicMeters other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(CubicMeters other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, CubicCentimeters argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, CubicCentimeters argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(CubicCentimeters other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(CubicCentimeters other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, CubicFeet argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, CubicFeet argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(CubicFeet other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(CubicFeet other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, CubicInches argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, CubicInches argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(CubicInches other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(CubicInches other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, CubicYards argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, CubicYards argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(CubicYards other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(CubicYards other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, FluidOuncesUK argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, FluidOuncesUK argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(FluidOuncesUK other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(FluidOuncesUK other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, FluidOunces argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, FluidOunces argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(FluidOunces other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(FluidOunces other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, PintsUK argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, PintsUK argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(PintsUK other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(PintsUK other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, Pints argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, Pints argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(Pints other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(Pints other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, QuartsUK argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, QuartsUK argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(QuartsUK other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(QuartsUK other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, Quarts argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, Quarts argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(Quarts other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(Quarts other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, GallonsUK argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, GallonsUK argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(GallonsUK other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(GallonsUK other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    	public static Volume operator +(Volume argA, Gallons argB)
        {
            return new Volume(argA.Value + ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, Gallons argB)
        {
            return new Volume(argA.Value - ((Volume)argB).ConvertTo(argA.UnitOfMeasure).Value, argA.UnitOfMeasure);
        }
    
    	public Volume Add(Gallons other)
        {
            return new Volume(Value + ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public Volume Subtract(Gallons other)
        {
            return new Volume(Value - ((Volume)other).ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
    
    
        public static Volume operator +(Volume argA, Volume argB)
        {
            if (argA._unitOfMeasure == argB._unitOfMeasure)
                return new Volume(argA.Value + argB.Value, argA._unitOfMeasure);
    
            return new Volume(argA.Value + argB.ConvertTo(argA._unitOfMeasure).Value, argA._unitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, Volume argB)
        {
            if (argA._unitOfMeasure == argB._unitOfMeasure)
                return new Volume(argA.Value - argB.Value, argA._unitOfMeasure);
    
            return new Volume(argA.Value - argB.ConvertTo(argA._unitOfMeasure).Value, argA._unitOfMeasure);
        }
    
    	public Volume Subtract(Volume argB)
        {
            if (UnitOfMeasure == argB._unitOfMeasure)
                return new Volume(Value - argB.Value,UnitOfMeasure);
    
            return new Volume(Value - argB.ConvertTo(UnitOfMeasure).Value, UnitOfMeasure);
        }
    
        public static Volume operator -(Volume argA, decimal argB)
        {
            return new Volume(argA.Value - argB, argA._unitOfMeasure);
        }
    
    
        public Volume Subtract(decimal argB)
        {
            return new Volume(Value - argB, UnitOfMeasure);
        }
    
    
        public static Volume operator +(Volume argA, decimal argB)
        {
            return new Volume(argA.Value + argB, argA._unitOfMeasure);
        }
    
        public static Volume operator *(Volume argA, decimal argB)
        {
            return new Volume(argA.Value * argB, argA._unitOfMeasure);
        }
    
        public Volume Multiply(decimal argB)
        {
            return new Volume(Value * argB, UnitOfMeasure);
        }
    
        public static Volume operator /(Volume argA, decimal argB)
        {
            return new Volume(argA.Value / argB, argA._unitOfMeasure);
        }
    
        public Volume Divide(decimal argB)
        {
            return new Volume(Value / argB, UnitOfMeasure);
        }
    
        #endregion
    
        #region ToString and TryParse
    
        /// <summary>
        /// Converts the current value to a formatted string.
        /// </summary>
        /// <remarks>
        /// Valid formatting values includes all formatting for decimals, as well as
        ///      g:                  The localized measure value in short form
        ///      G:                  The localized measure value in long form
        ///      u or uom:           The unit of measure in short form
        ///      U or UOM:           The unit of measure in long form
        /// </remarks>
        /// <param name="format">The format string</param>
        /// <param name="formatProvider">The format provider used to produce the string</param>
        /// <returns></returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            var provider = VolumeFormatProvider.GetInstance(formatProvider);
            return provider.Format(format, this, formatProvider);
        }
    
        public string ToString(string format)
        {
            return ToString(format, null);
        }
    
        public override string ToString()
        {
            return ToString("g", null);
        }
    
        #endregion
    
        #region TryParse
    
        /// <summary>
        /// Attempts to parse a string into a Volume value 
        /// </summary>
        /// <param name="formatProvider">The format provider to use for parsing</param>
        /// <param name="value">the string to parse</param>
        /// <param name="result">the parsed value</param>
        /// <returns>true, if succesful</returns>
        public static bool TryParse(string value, IFormatProvider formatProvider, out Volume result)
        {
            var provider = VolumeFormatProvider.GetInstance(formatProvider);
            return provider.TryParse(value, out result);
        }
    
        /// <summary>
        /// Attempts to parse a string into a Volume value 
        /// </summary>
        /// <param name="value">the string to parse</param>
        /// <param name="result">the parsed value</param>
        /// <returns>true, if succesful</returns>
        public static bool TryParse(string value, out Volume result)
        {
            return TryParse(value, null, out result);
        }
    
        #endregion
    
        #region IVolume Members
    
    	/// <summary>
        /// Gets this value as an unboxable property
        /// </summary>
        Volume IVolume.Volume
        {
            get { return this; }
        }
    
        #endregion
    
    	#region Conversion Units
    
    	internal static readonly decimal[] UnitsPerLiters = new decimal[] 
        {
    		Liters.UnitsPerLiters,
    		CubicMeters.UnitsPerLiters,
    		CubicCentimeters.UnitsPerLiters,
    		CubicFeet.UnitsPerLiters,
    		CubicInches.UnitsPerLiters,
    		CubicYards.UnitsPerLiters,
    		FluidOuncesUK.UnitsPerLiters,
    		FluidOunces.UnitsPerLiters,
    		PintsUK.UnitsPerLiters,
    		Pints.UnitsPerLiters,
    		QuartsUK.UnitsPerLiters,
    		Quarts.UnitsPerLiters,
    		GallonsUK.UnitsPerLiters,
    		Gallons.UnitsPerLiters
        };
    
    	internal static readonly decimal[] LiterssPerUnit = new decimal[] 
        {
    		Liters.LitersPerUnit,
    		CubicMeters.LitersPerUnit,
    		CubicCentimeters.LitersPerUnit,
    		CubicFeet.LitersPerUnit,
    		CubicInches.LitersPerUnit,
    		CubicYards.LitersPerUnit,
    		FluidOuncesUK.LitersPerUnit,
    		FluidOunces.LitersPerUnit,
    		PintsUK.LitersPerUnit,
    		Pints.LitersPerUnit,
    		QuartsUK.LitersPerUnit,
    		Quarts.LitersPerUnit,
    		GallonsUK.LitersPerUnit,
    		Gallons.LitersPerUnit
        };
    
    	#endregion
    
    }

}
